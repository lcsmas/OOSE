// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;    //Constructors ****************************************************  ChatIF serverUI;   /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF serverUI)   {    super(port);    this.serverUI = serverUI;  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient  (Object msg, ConnectionToClient client)  {	  if(isLogged(client.getInfo("id"))) {		  	  }	  if(msg.toString().startsWith("#logoff")) {		  try {			  client.close();		  } catch (IOException e) {}	  } 	  else if(msg.toString().startsWith("#login")) 	  {		  		  String idClient = msg.toString().split(" ")[1];		  if(!isLogged(idClient)) {			  client.setInfo("id", idClient);		  }		  	  }	  else {		  System.out.println("Message received: " + msg + " from " + client);		  this.sendToAllClients(msg);	  }  }  /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    System.out.println      ("Server listening for connections on port " + getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    System.out.println      ("Server has stopped listening for connections.");  }    //Class methods ***************************************************    @Override  protected synchronized void clientDisconnected(ConnectionToClient client) {	  System.out.println("A client disconnected");  }  public void handleMessageFromServerConsole(String message) {	  if(message.startsWith("#")) {		  try {		  handleCommand(message);		  }		  catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}	  }	  else sendToAllClients("Server MSG > " + message);	  serverUI.display(message);  }private void handleCommand(String message) throws IOException {	 if (message.startsWith("#quit")) {		  System.exit(0);	  }	 else if (message.startsWith("#stop")) {		 if(isListening()) {			 stop(); 		 }		 else {			 System.out.println("impossible le serveur n'ecoute deja plus");		 }	  }	 else if (message.startsWith("#close")) {		 sendToAllClients(message);		  close();	  }	 else if (message.startsWith("#start")) {		 if(!isListening()) {			 listen();		 }		 else {			 System.out.println("impossible le serveur ecoute deja");		 }	  }	  else if(message.startsWith("#setport")) {		  String[] port = message.split(" ");		  setPort(Integer.parseInt(port[1])); 	  }	  else if(message.startsWith("#getport")) {		  serverUI.display("port : "+ getPort());	  }	  else {		  serverUI.display("Commande incorrecte");	  }}private boolean isLogged(String idClient) {		Thread[] ctl_t = getClientConnections();		ConnectionToClient ctl = (ConnectionToClient) ctl_t;		return ctl.getInfo(idClient) != null ;}private void stop() {	stopListening();}  }//End of EchoServer class